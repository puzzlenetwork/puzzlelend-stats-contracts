{-# STDLIB_VERSION 6 #-}
{-# SCRIPT_TYPE ACCOUNT #-}
{-# CONTENT_TYPE DAPP #-}

let Waves = "WAVES"
let Scale6 = 1000000
let Scale8 = 100000000
let Scale8Big = 100000000.toBigInt()
let Scale10 = 10000000000
let Scale16 = 10000000000000000
let Scale16Big = 10000000000000000.toBigInt()
let dayBlocks = 1440
let yearBlocks = 525600
let yearBlocksBig = 525600.toBigInt()
let reserveFund = 20  # fee that goes to reserve fund in percents
let arr12 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]

let usdtIdStr = "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi"
let usdcIdStr = "HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW"
let romeIdStr = "AP4Cb5xLYGH6ZigHreCZHoXpQTWDkPsG2BHqfDUx6taJ"

let oracleAddressStr = "3P8d1E1BLKoD52y3bQJ1bDTd2TD1gpaLn9t"
let axlyAddress = Address(base58'3PLsYkBw7taejV1J3qWPCN2yeyVRu31d5HW')
let axlyLPs = ["7KZbJrVopwJhkdwbe1eFDBbex4dkY63MxjTNjqXtrzj1", "Btw3G1j4wQgdp49PTxaFkNvn75dQtqGDM7ejQppHnWC1", "BiSzFe8nSL78oZaebfoin5vBZ5Pze6d7kaeijLqr5xZe", "F2AKkA513k5yHEJkLsU6vWxCYYk811GpjLhwEv2WGwZ9", "4CQ5CPGLXLbWBUs2JBjKUaRqF49CmKHkwzvPgSvQpAQV", "6iMB6LKSrgv9waEvEnN6Ydyx7dfxPnGcTw8318WVm5bR"]

func getRateCurve(assetIdStr: String, marketStr: String) = {
    let marketAddress = addressFromStringValue(marketStr)
    let setupRateCurve = marketAddress.getString("setup_rateCurve_" + assetIdStr)
    if (setupRateCurve.isDefined()) then {
        let curveArr = setupRateCurve.value().split_4C(",")
        (parseIntValue(curveArr[0]), parseIntValue(curveArr[1]), parseIntValue(curveArr[2]), parseIntValue(curveArr[3]))
    } else
        match marketStr {
            case "3P4uA5etnZi4AmBabKinq2bMiWU8KcnHZdH" => {
                match assetIdStr {
                # (min rate, target rate, target ur, max rate)
                    case "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi" => (2000000, 25000000, 80000000, 100000000)
                    case "HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW" => (2000000, 25000000, 80000000, 100000000)
                    case "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ" => (2000000, 25000000, 80000000, 100000000)
                    case "6XtHjpXbs9RRJP2Sr9GUyVqzACcby9TkThHXnjVC5CDJ" => (2000000, 25000000, 80000000, 100000000)
                    case "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p" => (2000000, 25000000, 80000000, 100000000)
                    case "Ajso6nTTjptu2UHLx6hfSXVtHFtRBJCkKYd5SAyj7zf5" => (2000000, 40000000, 80000000, 150000000)
                    case "HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS" => (0, 100000000, 80000000, 400000000)
                    case "WAVES" => (2000000, 30000000, 80000000, 90000000)
                    case "Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on" => (0, 20000000, 80000000, 40000000)
                    case "DSbbhLsSTeDg5Lsiufk2Aneh3DjVqJuPr2M9uU1gwy5p" => (0, 20000000, 80000000, 100000000)
                    case "8t4DPWTwPzpatHA9AkTxWAB47THnYzBsDnoY7fQqbG91" => (0, 30000000, 80000000, 40000000)
                    case "At8D6NFFpheCbvKVnjVoeLL84Eo8NZn6ovManxfLaFWL" => (0, 25000000, 80000000, 40000000)
                    case "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS" => (2000000, 30000000, 80000000, 50000000) # BTC
                    case "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu" => (2000000, 30000000, 80000000, 50000000) # ETH
                    case "5UYBPpq4WoU5n4MwpFkgJnW3Fq4B1u3ukpK33ik4QerR" => (2000000, 30000000, 80000000, 50000000) # BNB
                    case "2thsACuHmzDMuNezPM32wg9a3BwUzBWDeSKakgz3cw21" => (2000000, 40000000, 80000000, 100000000) # POWER
                    case "YiNbofFzC17jEHHCMwrRcpy9MrrjabMMLZxg8g5xmf7" => (2000000, 30000000, 80000000, 80000000) # SWAVES
                    case "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi" => (0, 50000000, 80000000, 200000000) # USDT-PPT
                    case "3VuV5WTmDz47Dmdn3QpcYjzbSdipjQE4JMdNe1xZpX13" => (0, 100000000, 80000000, 400000000) # ETH-PPT
                    case _ => (0, 20000000, 80000000, 80000000)
                }
            }
            case "3P8Df2b7ywHtLBHBe8PBVQYd3A5MdEEJAou" => (20000000, 100000000, 60000000, 400000000)
            case "3P4DK5VzDwL3vfc5ahUEhtoe5ByZNyacJ3X" => {
                match assetIdStr {
                    case "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi" => (2000000, 25000000, 80000000, 100000000)
                    case "HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW" => (2000000, 25000000, 80000000, 100000000)
                    case "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ" => (2000000, 25000000, 80000000, 100000000)
                    case "6XtHjpXbs9RRJP2Sr9GUyVqzACcby9TkThHXnjVC5CDJ" => (2000000, 25000000, 80000000, 100000000)
                    case "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p" => (2000000, 25000000, 80000000, 100000000)
                    case "Ajso6nTTjptu2UHLx6hfSXVtHFtRBJCkKYd5SAyj7zf5" => (2000000, 40000000, 80000000, 150000000)
                    case "HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS" => (0, 50000000, 80000000, 400000000)
                    case "WAVES" => (2000000, 30000000, 80000000, 80000000)
                    case "Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on" => (0, 20000000, 80000000, 40000000)
                    case "DSbbhLsSTeDg5Lsiufk2Aneh3DjVqJuPr2M9uU1gwy5p" => (0, 20000000, 80000000, 100000000)
                    case "8t4DPWTwPzpatHA9AkTxWAB47THnYzBsDnoY7fQqbG91" => (0, 30000000, 80000000, 40000000)
                    case "At8D6NFFpheCbvKVnjVoeLL84Eo8NZn6ovManxfLaFWL" => (0, 25000000, 80000000, 40000000)
                    case "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS" => (2000000, 30000000, 80000000, 50000000)
                    case "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu" => (2000000, 30000000, 80000000, 50000000)
                    case "5UYBPpq4WoU5n4MwpFkgJnW3Fq4B1u3ukpK33ik4QerR" => (2000000, 30000000, 80000000, 50000000)
                    case "2thsACuHmzDMuNezPM32wg9a3BwUzBWDeSKakgz3cw21" => (2000000, 40000000, 80000000, 100000000)
                    case "YiNbofFzC17jEHHCMwrRcpy9MrrjabMMLZxg8g5xmf7" => (2000000, 30000000, 80000000, 80000000)
                    case "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi" => (0, 50000000, 80000000, 200000000)
                    case "3VuV5WTmDz47Dmdn3QpcYjzbSdipjQE4JMdNe1xZpX13" => (0, 100000000, 80000000, 400000000)
                    case _ => (0, 20000000, 80000000, 80000000)
                }
            }
            case "3PHpuQUPVUoR3AYzFeJzeWJfYLsLTmWssVH" => (20000000, 100000000, 60000000, 400000000)
            case "3PAd9Aqg3cQSzu26MFYWQYcjSXPVCJtuf5V" => {
                match assetIdStr {
                    case "9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi" => (2000000, 25000000, 80000000, 100000000)
                    case "HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW" => (2000000, 25000000, 80000000, 100000000)
                    case "34N9YcEETLWn93qYQ64EsP1x89tSruJU44RrEMSXXEPJ" => (2000000, 25000000, 80000000, 100000000)
                    case "6XtHjpXbs9RRJP2Sr9GUyVqzACcby9TkThHXnjVC5CDJ" => (2000000, 25000000, 80000000, 100000000)
                    case "DG2xFkPdDwKUoBkzGAhQtLpSGzfXLiCYPEzeKH2Ad24p" => (2000000, 25000000, 80000000, 100000000)
                    case "Ajso6nTTjptu2UHLx6hfSXVtHFtRBJCkKYd5SAyj7zf5" => (2000000, 40000000, 80000000, 150000000)
                    case "HEB8Qaw9xrWpWs8tHsiATYGBWDBtP2S7kcPALrMu43AS" => (0, 20000000, 80000000, 40000000)
                    case "WAVES" => (2000000, 30000000, 80000000, 50000000)
                    case "Atqv59EYzjFGuitKVnMRk6H8FukjoV3ktPorbEys25on" => (0, 20000000, 80000000, 40000000)
                    case "DSbbhLsSTeDg5Lsiufk2Aneh3DjVqJuPr2M9uU1gwy5p" => (0, 20000000, 80000000, 100000000)
                    case "8t4DPWTwPzpatHA9AkTxWAB47THnYzBsDnoY7fQqbG91" => (0, 30000000, 80000000, 40000000)
                    case "At8D6NFFpheCbvKVnjVoeLL84Eo8NZn6ovManxfLaFWL" => (0, 25000000, 80000000, 40000000)
                    case "8LQW8f7P5d5PZM7GtZEBgaqRPGSzS3DfPuiXrURJ4AJS" => (2000000, 30000000, 80000000, 50000000)
                    case "474jTeYx2r2Va35794tCScAXWJG9hU2HcgxzMowaZUnu" => (2000000, 30000000, 80000000, 50000000)
                    case "5UYBPpq4WoU5n4MwpFkgJnW3Fq4B1u3ukpK33ik4QerR" => (2000000, 30000000, 80000000, 50000000)
                    case "2thsACuHmzDMuNezPM32wg9a3BwUzBWDeSKakgz3cw21" => (2000000, 40000000, 80000000, 100000000)
                    case "YiNbofFzC17jEHHCMwrRcpy9MrrjabMMLZxg8g5xmf7" => (2000000, 30000000, 80000000, 80000000)
                    case _ => (0, 20000000, 80000000, 80000000)
                }
            }
            case _ => throw("Unknown market")
        }
}

func sum(size: Int, data: List[Int]) = {
    func fold(accum: Int, next: Int) = {
        if (next >= size) then accum else
            accum + data[next]
    }

    FOLD<12>(arr12, 0, fold)
}

func getSetupTokens(marketAddress: Address) = {
    marketAddress.getStringValue("setup_tokens").split_4C(",")
}

func getTokenPrice(marketAddress: Address, assetIdStr: String) = {
    let oracleStr = marketAddress.getString("oracle").valueOrElse(oracleAddressStr)
    let oracleAddress = addressFromStringValue(oracleStr)
    let stables = marketAddress.getString("setup_stablesIds").valueOrElse("9wc3LXNA4TEBsXyKtoLE9mrbDD7WMHXvXrCjZvabLAsi,HGgabTqUS8WtVFUJzfmrTDMgEccJuZLBPhFgQFxvnsoW").split_4C(",")
    if (stables.indexOf(assetIdStr) != unit) then 1000000 else
    if (assetIdStr == usdtIdStr || assetIdStr == usdcIdStr || assetIdStr == romeIdStr) then 1000000 else
    if (axlyLPs.containsElement(assetIdStr)) then invoke(axlyAddress, "getShareAssetPriceREADONLY", [assetIdStr], nil).exactAs[Int] else
        let price = getIntegerValue(oracleAddress, assetIdStr + "_twap5B")
        price
}

func getAssetScale(assetIdStr: String) = {
    let decimals = if (assetIdStr == "WAVES") then 8 else assetInfo(assetIdStr.fromBase58String()).value().decimals
    pow(10, 0, decimals, 0, 0, DOWN)
}

func getLastRateHeight(marketAddress: Address) = {
    marketAddress.getInteger("lastRateHeight").valueOrElse(0)
}

func getOutdatedTotalSupply(marketAddress: Address, assetIdStr: String) = {
    marketAddress.getInteger("total_supplied_" + assetIdStr).valueOrElse(0)
}

func getOutdatedTotalBorrow(marketAddress: Address, assetIdStr: String) = {
    marketAddress.getInteger("total_borrowed_" + assetIdStr).valueOrElse(0)
}

func getOutdatedSRate(marketAddress: Address, assetIdStr: String) = {
    marketAddress.getInteger(assetIdStr + "_sRate").valueOrElse(0)
}

func getOutdatedBRate(marketAddress: Address, assetIdStr: String) = {
    marketAddress.getInteger(assetIdStr + "_bRate").valueOrElse(0)
}

func getOutdatedUr(outdatedTotalSupply: Int, outdatedTotalBorrow: Int, outdatedSRate: Int, outdatedBRate: Int) = {
    let down = fraction(outdatedTotalSupply, outdatedSRate, Scale16)
    if (down == 0) then {
        0
    }
    else {
        fraction(Scale8,
        fraction(outdatedTotalBorrow, outdatedBRate, Scale16),
        down)
    }
}

func getRate(outdatedUr: Int, assetIdStr: String, marketStr: String) = {
    let curve = getRateCurve(assetIdStr, marketStr)
    curve._1 + if (outdatedUr <= curve._3) then {
        fraction(outdatedUr, curve._2, curve._3)
    } else {
        curve._2 + fraction(outdatedUr - curve._3, curve._4, 100000000 - curve._3)
    }
}

func getInterest(rate: Int) = {
# return interest per block
    max([fraction(rate, Scale8, yearBlocks), 1])
}

func getAssetIndex(setupTokens: List[String], assetIdStr: String) = {
    setupTokens.indexOf(assetIdStr).value()
}

func getAssetParamters(marketParameters: (List[Int], List[Int], List[Int]), assetIndex: Int) = {
    (marketParameters._1[assetIndex], marketParameters._2[assetIndex], marketParameters._3[assetIndex])
}

func getMarketParameters(marketAddress: Address, setupTokens: List[String]) = {
    let setupCf = marketAddress.getStringValue("setup_ltvs").split_4C(",")
    let setupLt = marketAddress.getStringValue("setup_lts").split_4C(",")
    let setupPenalty = marketAddress.getStringValue("setup_penalties").split_4C(",")

    let tokensSize = setupTokens.size()
    func fold(accum: (List[Int], List[Int], List[Int]), next: Int) = {
        if (next >= tokensSize) then accum else
            (
                accum._1 :+ setupCf[next].parseIntValue(),
                accum._2 :+ setupLt[next].parseIntValue(),
                accum._3 :+ setupPenalty[next].parseIntValue()
            )
    }

    FOLD<12>(arr12, ([], [], []), fold)
}

func getMaxSupply(marketAddress: Address, assetIdStr: String) = {
    marketAddress.getString("setup_maxSupply_" + assetIdStr).valueOrElse("0").parseIntValue()
}

func getActualSRate(lastRateHeight: Int, interest: Int, outdatedUr: Int, outdatedSRate: Int) = {
    let lastSRate = max([outdatedSRate, Scale16])
    let newSRate = lastSRate + (height - lastRateHeight) * fraction(interest, outdatedUr, Scale8) * (100 - reserveFund) / 100
    newSRate
}

func getActualBRate(lastRateHeight: Int, interest: Int, outdatedBRate: Int) = {
    let lastBRate = max([outdatedBRate, Scale16])
    let newBRate = lastBRate + (height - lastRateHeight) * interest
    newBRate
}

func getActualUr(actualSupply: Int, actualBorrow: Int) = {
    if (actualSupply == 0) then 0 else fraction(actualBorrow, Scale8, actualSupply)
}

func getActualAmount(outdatedAmount: Int, actualRate: Int) = {
    fraction(outdatedAmount, actualRate, Scale16)
}

func getInUsd(actualAmount: Int, assetScale: Int, price: Int) = {
    fraction(actualAmount, price, assetScale)
}

func getSupplyApy(rate: Int, actualUr: Int) = {
    let supplyRate = fraction(fraction(rate, 80, 100), actualUr, Scale8)
    pow(Scale16Big + fraction(supplyRate.toBigInt(), Scale8Big, yearBlocksBig), 16, yearBlocksBig, 0, 8, DOWN).toInt() - Scale8
}

func getBorrowApy(rate: Int) = {
    pow(Scale16Big + fraction(rate.toBigInt(), Scale8Big, yearBlocksBig), 16, yearBlocksBig, 0, 8, DOWN).toInt() - Scale8
}

func getWalletSupply(marketAddress: Address, assetIdStr: String, wallet: String, actualSRate: Int) = {
    let outdatedWalletSupply = marketAddress.getInteger(wallet + "_supplied_" + assetIdStr).valueOrElse(0)
    getActualAmount(outdatedWalletSupply, actualSRate)
}

func getWalletBorrow(marketAddress: Address, assetIdStr: String, wallet: String, actualBRate: Int) = {
    let outdatedWalletBorrow = marketAddress.getInteger(wallet + "_borrowed_" + assetIdStr).valueOrElse(0)
    getActualAmount(outdatedWalletBorrow, actualBRate)
}

func getDailyPercents(apy: Int, quantity: Int) = {
    fraction(fraction(pow(Scale8Big + apy.toBigInt(), 8, Scale16Big / yearBlocksBig, 16, 16, DOWN).toInt() - Scale16, dayBlocks, Scale8), quantity, Scale8)
}

func getAccountHealth(totalWalletBorrowLimitInUsd: Int, totalWalletBorrowUsageInUsd: Int) = {
    if (totalWalletBorrowLimitInUsd == 0) then Scale8 else
        Scale8 - fraction(totalWalletBorrowUsageInUsd, Scale8, totalWalletBorrowLimitInUsd)
}

func getNetApy(totalWalletSupplyInUsd: Int, totalWalletBorrowInUsd: Int, totalWalletMarginInUsd: Int) = {
    if (totalWalletMarginInUsd == 0) then 0 else
    if (totalWalletMarginInUsd > 0)
    then fraction(totalWalletMarginInUsd, Scale8, totalWalletSupplyInUsd)
    else fraction(totalWalletMarginInUsd, Scale8, totalWalletBorrowInUsd)
}

func assetToJson(assetIdStr: String, quantity: Int) = {
    let (decimals, name) = if (assetIdStr == Waves) then
        (8, "WAVES")
    else {
        let asset = assetInfo(fromBase58String(assetIdStr)).value()
        (asset.decimals, asset.name)
    }

    "{\"quantity\":" + quantity.toString() + ",\"decimals\":" + decimals.toString() + ",\"name\":\"" + name + "\",\"id\":\"" + assetIdStr + "\"}"
}

func amountToDecimal(amount: Int, decimals: Int) = {
    "{\"quantity\":" + amount.toString() + ",\"decimals\":" + decimals.toString() + ",\"name\":\"\",\"id\":\"\"}"
}

func getMarketJson(marketIndex: Int, wallet: String, debug: Boolean) = {
    let marketStr = getStringValue("market_" + marketIndex.toString())
    let marketAddress = addressFromStringValue(marketStr)
    let marketName = getStringValue("market_name_" + marketStr)
    let active = marketAddress.getBoolean("setup_active").valueOrElse(true)
    let setupTokens = getSetupTokens(marketAddress)
    let assetsCount = setupTokens.size()
    let lastRateHeight = getLastRateHeight(marketAddress)

    func assetsFold(accum: (Int, Int, Int, List[String]), next: Int) = {
        if (next >= assetsCount) then accum else

            let assetIdStr = setupTokens[next]
            let price = getTokenPrice(marketAddress, assetIdStr)
            let assetScale = getAssetScale(assetIdStr)
            let outdatedTotalSupply = getOutdatedTotalSupply(marketAddress, assetIdStr)
            let outdatedTotalBorrow = getOutdatedTotalBorrow(marketAddress, assetIdStr)
            let outdatedSRate = getOutdatedSRate(marketAddress, assetIdStr)
            let outdatedBRate = getOutdatedBRate(marketAddress, assetIdStr)
            let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
            let rate = getRate(outdatedUr, assetIdStr, marketStr)
            let interest = getInterest(rate)
            let sRate = getActualSRate(lastRateHeight, interest, outdatedUr, outdatedSRate)
            let bRate = getActualBRate(lastRateHeight, interest, outdatedBRate)
            let supply = getActualAmount(outdatedTotalSupply, sRate)
            let borrow = getActualAmount(outdatedTotalBorrow, bRate)
            let supplyInUsd = getInUsd(supply, assetScale, price)
            let borrowInUsd = getInUsd(borrow, assetScale, price)
            let reserves = supply - borrow
            let reservesInUsd = getInUsd(reserves, assetScale, price)
            let ur = getActualUr(supply, borrow)
            let supplyApy = getSupplyApy(rate, ur)
            let borrowApy = getBorrowApy(rate)
            let marketAssetJson =
            "{" +
            "\"supply\":" + assetToJson(assetIdStr, supply) +
            ",\"supplyInUsd\":" + assetToJson(usdtIdStr, supplyInUsd) +
            ",\"borrow\":" + assetToJson(assetIdStr, borrow) +
            ",\"borrowInUsd\":" + assetToJson(usdtIdStr, borrowInUsd) +
            ",\"reserves\":" + assetToJson(assetIdStr, reserves) +
            ",\"reservesInUsd\":" + assetToJson(usdtIdStr, reservesInUsd) +
            ",\"price\":" + assetToJson(usdtIdStr, price) +
            ",\"supplyApy\":" + amountToDecimal(supplyApy, 8) +
            ",\"borrowApy\":" + amountToDecimal(borrowApy, 8) +
            ",\"utilizationRatio\":" + amountToDecimal(ur, 8) +
            ",\"sRate\":" + amountToDecimal(sRate, 16) +
            ",\"bRate\":" + amountToDecimal(bRate, 16) +
            "}"

            (
                accum._1 + supplyInUsd,
                accum._2 + borrowInUsd,
                accum._3 + reservesInUsd,
                accum._4 :+ marketAssetJson
            )
    }

    let (supplyInUsd, borrowInUsd, reservesInUsd, marketAssetsJson) = FOLD<12>(arr12, (0, 0, 0, []), assetsFold)

    let marketsCount = getIntegerValue("markets")

    func marketsFold(accum: List[String], next: Int) = {
        if (next >= marketsCount) then accum else
            let currentMarketAddressStr = getStringValue("market_" + next.toString())
            let currentMarketName = getStringValue("market_name_" + currentMarketAddressStr)
            let simpleJson =
            "{" +
            "\"index\":" + next.toString() +
            ",\"name\":\"" + currentMarketName + "\"" +
            ",\"supplyInUsd\":" + assetToJson(usdtIdStr, 0) +
            ",\"accountHealth\":" + amountToDecimal(0, 8) +
            "}"

            if (wallet == "") then accum :+ simpleJson else

                let currentMarketAddress = addressFromStringValue(currentMarketAddressStr)
                let currentSetupTokens = getSetupTokens(currentMarketAddress)
                let currentAssetsCount = currentSetupTokens.size()
                let currentMarketShortName = getStringValue("market_shortname_" + currentMarketAddressStr)
                let setupCf = currentMarketAddress.getStringValue("setup_ltvs").split_4C(",")
                let setupLt = currentMarketAddress.getStringValue("setup_lts").split_4C(",")
                let currentLastRateHeight = getLastRateHeight(currentMarketAddress)

                func marketAssetsFold(accum: (Int, Int, Int, Int), next: Int) = {
                    if (next >= currentAssetsCount) then accum else

                        let assetIdStr = currentSetupTokens[next]
                        let cf = setupCf[next].parseIntValue()
                        let lt = setupLt[next].parseIntValue()
                        let price = getTokenPrice(marketAddress, assetIdStr)
                        let assetScale = getAssetScale(assetIdStr)
                        let outdatedTotalSupply = getOutdatedTotalSupply(currentMarketAddress, assetIdStr)
                        let outdatedTotalBorrow = getOutdatedTotalBorrow(currentMarketAddress, assetIdStr)
                        let outdatedSRate = getOutdatedSRate(currentMarketAddress, assetIdStr)
                        let outdatedBRate = getOutdatedBRate(currentMarketAddress, assetIdStr)
                        let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
                        let rate = getRate(outdatedUr, assetIdStr, marketStr)
                        let interest = getInterest(rate)
                        let sRate = getActualSRate(currentLastRateHeight, interest, outdatedUr, outdatedSRate)
                        let bRate = getActualBRate(currentLastRateHeight, interest, outdatedBRate)

                        let walletSupply = getWalletSupply(currentMarketAddress, assetIdStr, wallet, sRate)
                        let walletSupplyInUsd = getInUsd(walletSupply, assetScale, price)
                        let walletBorrow = getWalletBorrow(currentMarketAddress, assetIdStr, wallet, bRate)
                        let walletBorrowInUsd = getInUsd(walletBorrow, assetScale, price)
                        let walletBorrowLimitInUsd = fraction(walletSupplyInUsd, cf, Scale8)
                        let walletBorrowUsageInUsd = fraction(walletBorrowInUsd, Scale8, lt)

                        (
                            accum._1 + walletSupplyInUsd,
                            accum._2 + walletBorrowInUsd,
                            accum._3 + walletBorrowLimitInUsd,
                            accum._4 + walletBorrowUsageInUsd
                        )
                }

                let (totalWalletSupplyInUsd, totalWalletBorrowInUsd, totalWalletBorrowLimitInUsd, totalWalletBorrowUsageInUsd) = FOLD<12>(arr12, (0, 0, 0, 0), marketAssetsFold)
                let accountHealth = getAccountHealth(totalWalletBorrowLimitInUsd, totalWalletBorrowUsageInUsd)

                let fullJson =
                "{" +
                "\"index\":" + next.toString() +
                ",\"name\":\"" + currentMarketShortName + "\"" +
                ",\"supplyInUsd\":" + assetToJson(usdtIdStr, totalWalletSupplyInUsd) +
                ",\"borrowInUsd\":" + assetToJson(usdtIdStr, totalWalletBorrowInUsd) +
                ",\"accountHealth\":" + amountToDecimal(accountHealth, 8) +
                "}"

                accum :+ fullJson
    }

    let marketsJson = FOLD<12>(arr12, [], marketsFold)

    let json =
    "{" +
    "\"index\":" + marketIndex.toString() +
    ",\"name\":\"" + marketName + "\"" +
    ",\"address\":\"" + marketStr + "\"" +
    ",\"active\":" + active.toString() +
    ",\"supplyInUsd\":" + assetToJson(usdtIdStr, supplyInUsd) +
    ",\"borrowInUsd\":" + assetToJson(usdtIdStr, borrowInUsd) +
    ",\"reservesInUsd\":" + assetToJson(usdtIdStr, reservesInUsd) +
    ",\"assets\":[" + makeString_11C(marketAssetsJson, ",") + "]" +
    ",\"markets\":[" + makeString_11C(marketsJson, ",") + "]" +
    "}"

    if (debug) then throw(json) else json
}

func getMenuJson(debug: Boolean) = {
    let marketsCount = getIntegerValue("markets")

    func marketsFold(accum: (Int, Int, Int, List[String]), next: Int) = {
        if (next >= marketsCount) then accum else

            let marketStr = getStringValue("market_" + next.toString())
            let marketAddress = addressFromStringValue(marketStr)
            let setupTokens = getSetupTokens(marketAddress)
            let assetsCount = setupTokens.size()
            let lastRateHeight = getLastRateHeight(marketAddress)

            func assetsFold(accum: (Int, Int, Int, List[String]), next: Int) = {
                if (next >= assetsCount) then accum else

                    let assetIdStr = setupTokens[next]
                    let price = getTokenPrice(marketAddress, assetIdStr)
                    let assetScale = getAssetScale(assetIdStr)
                    let outdatedTotalSupply = getOutdatedTotalSupply(marketAddress, assetIdStr)
                    let outdatedTotalBorrow = getOutdatedTotalBorrow(marketAddress, assetIdStr)
                    let outdatedSRate = getOutdatedSRate(marketAddress, assetIdStr)
                    let outdatedBRate = getOutdatedBRate(marketAddress, assetIdStr)
                    let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
                    let rate = getRate(outdatedUr, assetIdStr, marketStr)
                    let interest = getInterest(rate)
                    let sRate = getActualSRate(lastRateHeight, interest, outdatedUr, outdatedSRate)
                    let bRate = getActualBRate(lastRateHeight, interest, outdatedBRate)
                    let supply = getActualAmount(outdatedTotalSupply, sRate)
                    let borrow = getActualAmount(outdatedTotalBorrow, bRate)
                    let supplyInUsd = getInUsd(supply, assetScale, price)
                    let borrowInUsd = getInUsd(borrow, assetScale, price)
                    let reserves = supply - borrow
                    let reservesInUsd = getInUsd(reserves, assetScale, price)
                    let marketAssetJson =
                    "{" +
                    "\"asset\":" + assetToJson(assetIdStr, 0) +
                    ",\"price\":" + assetToJson(usdtIdStr, price) +
                    ",\"sRate\":" + amountToDecimal(sRate, 16) +
                    ",\"bRate\":" + amountToDecimal(bRate, 16) +
                    "}"

                    (
                        accum._1 + supplyInUsd,
                        accum._2 + borrowInUsd,
                        accum._3 + reservesInUsd,
                        accum._4 :+ marketAssetJson
                    )
            }

            let (supplyInUsd, borrowInUsd, reservesInUsd, marketAssetsJson) = FOLD<12>(arr12, (0, 0, 0, []), assetsFold)
            let marketJson =
            "{" +
            "\"address\":\"" + marketStr + "\"" +
            ",\"assets\":[" + makeString_11C(marketAssetsJson, ",") + "]" +
            "}"

            (
                accum._1 + supplyInUsd,
                accum._2 + borrowInUsd,
                accum._3 + reservesInUsd,
                accum._4 :+ marketJson
            )
    }

    let (totalSupplyInUsd, totalBorrowInUsd, totalReservesInUsd, marketsJson) = FOLD<12>(arr12, (0, 0, 0, []), marketsFold)

    let json =
    "{" +
    "\"supplyInUsd\":" + assetToJson(usdtIdStr, totalSupplyInUsd) +
    ",\"borrowInUsd\":" + assetToJson(usdtIdStr, totalBorrowInUsd) +
    ",\"reservesInUsd\":" + assetToJson(usdtIdStr, totalReservesInUsd) +
    ",\"markets\":[" + makeString_11C(marketsJson, ",") + "]" +
    "}"

    if (debug) then throw(json) else json
}

func getWalletJson(marketIndex: Int, wallet: String, debug: Boolean) = {
    let marketStr = getStringValue("market_" + marketIndex.toString())
    let marketAddress = addressFromStringValue(marketStr)
    let marketName = getStringValue("market_name_" + marketStr)
    let marketsCount = getIntegerValue("markets")

    func marketsFold(accum: (Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, Int, List[String], List[String], List[String]), next: Int) = {
        if (next >= marketsCount) then accum else
            let currentMarketAddressStr = getStringValue("market_" + next.toString())
            let currentMarketName = getStringValue("market_name_" + currentMarketAddressStr)
            let currentMarketAddress = addressFromStringValue(currentMarketAddressStr)
            let currentSetupTokens = getSetupTokens(currentMarketAddress)
            let currentAssetsCount = currentSetupTokens.size()
            let currentMarketShortName = getStringValue("market_shortname_" + currentMarketAddressStr)
            let setupCf = currentMarketAddress.getStringValue("setup_ltvs").split_4C(",")
            let setupLt = currentMarketAddress.getStringValue("setup_lts").split_4C(",")
            let currentLastRateHeight = getLastRateHeight(currentMarketAddress)

            func marketAssetsFold(accum: (Int, Int, Int, Int, Int, Int, Int), next: Int) = {
                if (next >= currentAssetsCount) then accum else

                    let assetIdStr = currentSetupTokens[next]
                    let cf = setupCf[next].parseIntValue()
                    let lt = setupLt[next].parseIntValue()
                    let price = getTokenPrice(marketAddress, assetIdStr)
                    let assetScale = getAssetScale(assetIdStr)
                    let outdatedTotalSupply = getOutdatedTotalSupply(currentMarketAddress, assetIdStr)
                    let outdatedTotalBorrow = getOutdatedTotalBorrow(currentMarketAddress, assetIdStr)
                    let outdatedSRate = getOutdatedSRate(currentMarketAddress, assetIdStr)
                    let outdatedBRate = getOutdatedBRate(currentMarketAddress, assetIdStr)
                    let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
                    let rate = getRate(outdatedUr, assetIdStr, marketStr)
                    let interest = getInterest(rate)
                    let sRate = getActualSRate(currentLastRateHeight, interest, outdatedUr, outdatedSRate)
                    let bRate = getActualBRate(currentLastRateHeight, interest, outdatedBRate)
                    let supply = getActualAmount(outdatedTotalSupply, sRate)
                    let borrow = getActualAmount(outdatedTotalBorrow, bRate)
                    let ur = getActualUr(supply, borrow)
                    let supplyApy = getSupplyApy(rate, ur)
                    let borrowApy = getBorrowApy(rate)

                    let walletSupply = getWalletSupply(currentMarketAddress, assetIdStr, wallet, sRate)
                    let walletSupplyInUsd = getInUsd(walletSupply, assetScale, price)
                    let walletBorrow = getWalletBorrow(currentMarketAddress, assetIdStr, wallet, bRate)
                    let walletBorrowInUsd = getInUsd(walletBorrow, assetScale, price)
                    let walletBorrowLimitInUsd = fraction(walletSupplyInUsd, cf, Scale8)
                    let walletBorrowUsageInUsd = fraction(walletBorrowInUsd, Scale8, lt)
                    let walletDailyIncome = getDailyPercents(supplyApy, walletSupply)
                    let walletDailyIncomeInUsd = getInUsd(walletDailyIncome, assetScale, price)
                    let walletDailyLoanInterest = getDailyPercents(borrowApy, walletBorrow)
                    let walletDailyLoanInterestInUsd = getInUsd(walletDailyLoanInterest, assetScale, price)
                    let walletMarginInUsd = fraction(walletSupplyInUsd, supplyApy, Scale8) - fraction(walletBorrowInUsd, borrowApy, Scale8)

                    (
                        accum._1 + walletSupplyInUsd,
                        accum._2 + walletBorrowInUsd,
                        accum._3 + walletBorrowLimitInUsd,
                        accum._4 + walletBorrowUsageInUsd,
                        accum._5 + walletDailyIncomeInUsd,
                        accum._6 + walletDailyLoanInterestInUsd,
                        accum._7 + walletMarginInUsd
                    )
            }

            let (
            totalWalletSupplyInUsd,
            totalWalletBorrowInUsd,
            totalWalletBorrowLimitInUsd,
            totalWalletBorrowUsageInUsd,
            totalWalletDailyIncomeInUsd,
            totalWalletDailyLoanInterestInUsd,
            totalWalletMarginInUsd
            ) = FOLD<12>(arr12, (0, 0, 0, 0, 0, 0, 0), marketAssetsFold)
            let totalWalletBadDebtInUsd = if (totalWalletBorrowInUsd > totalWalletSupplyInUsd) then totalWalletBorrowInUsd - totalWalletSupplyInUsd else 0
            let accountHealth = getAccountHealth(totalWalletBorrowLimitInUsd, totalWalletBorrowUsageInUsd)
            let netApy = getNetApy(totalWalletSupplyInUsd, totalWalletBorrowInUsd, totalWalletMarginInUsd)

            let marketsJson =
            "{" +
            "\"index\":" + next.toString() +
            ",\"name\":\"" + currentMarketShortName + "\"" +
            ",\"supplyInUsd\":" + assetToJson(usdtIdStr, totalWalletSupplyInUsd) +
            ",\"borrowInUsd\":" + assetToJson(usdtIdStr, totalWalletBorrowInUsd) +
            ",\"accountHealth\":" + amountToDecimal(accountHealth, 8) +
            "}"

            func walletAssetsFold(accum: (List[String], List[String]), next: Int) = {
                if (next >= currentAssetsCount) then accum else

                    let assetIdStr = currentSetupTokens[next]
                    let price = getTokenPrice(marketAddress, assetIdStr)
                    let assetScale = getAssetScale(assetIdStr)
                    let outdatedTotalSupply = getOutdatedTotalSupply(currentMarketAddress, assetIdStr)
                    let outdatedTotalBorrow = getOutdatedTotalBorrow(currentMarketAddress, assetIdStr)
                    let outdatedSRate = getOutdatedSRate(currentMarketAddress, assetIdStr)
                    let outdatedBRate = getOutdatedBRate(currentMarketAddress, assetIdStr)
                    let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
                    let rate = getRate(outdatedUr, assetIdStr, marketStr)
                    let interest = getInterest(rate)
                    let sRate = getActualSRate(currentLastRateHeight, interest, outdatedUr, outdatedSRate)
                    let bRate = getActualBRate(currentLastRateHeight, interest, outdatedBRate)
                    let supply = getActualAmount(outdatedTotalSupply, sRate)
                    let borrow = getActualAmount(outdatedTotalBorrow, bRate)
                    let ur = getActualUr(supply, borrow)
                    let supplyApy = getSupplyApy(rate, ur)
                    let borrowApy = getBorrowApy(rate)

                    let walletSupply = getWalletSupply(currentMarketAddress, assetIdStr, wallet, sRate)
                    let walletSupplyInUsd = getInUsd(walletSupply, assetScale, price)
                    let walletBorrow = getWalletBorrow(currentMarketAddress, assetIdStr, wallet, bRate)
                    let walletBorrowInUsd = getInUsd(walletBorrow, assetScale, price)
                    let walletDailyIncome = getDailyPercents(supplyApy, walletSupply)
                    let walletDailyIncomeInUsd = getInUsd(walletDailyIncome, assetScale, price)
                    let walletDailyLoanInterest = getDailyPercents(borrowApy, walletBorrow)
                    let walletDailyLoanInterestInUsd = getInUsd(walletDailyLoanInterest, assetScale, price)

                    let supplyAssetsJson =
                    "{" +
                    "\"amount\":" + assetToJson(assetIdStr, walletSupply) +
                    ",\"amountInUsd\":" + assetToJson(usdtIdStr, walletSupplyInUsd) +
                    ",\"price\":" + assetToJson(usdtIdStr, price) +
                    ",\"apy\":" + amountToDecimal(supplyApy, 8) +
                    ",\"dailyPercents\":" + assetToJson(assetIdStr, walletDailyIncome) +
                    ",\"dailyPercentsInUsd\":" + assetToJson(usdtIdStr, walletDailyIncomeInUsd) +
                    "}"

                    let borrowAssetsJson =
                    "{" +
                    "\"amount\":" + assetToJson(assetIdStr, walletBorrow) +
                    ",\"amountInUsd\":" + assetToJson(usdtIdStr, walletBorrowInUsd) +
                    ",\"price\":" + assetToJson(usdtIdStr, price) +
                    ",\"apy\":" + amountToDecimal(borrowApy, 8) +
                    ",\"dailyPercents\":" + assetToJson(assetIdStr, walletDailyLoanInterest) +
                    ",\"dailyPercentsInUsd\":" + assetToJson(usdtIdStr, walletDailyLoanInterestInUsd) +
                    "}"

                    (
                        accum._1 :+ supplyAssetsJson,
                        accum._2 :+ borrowAssetsJson
                    )
            }

            let (supplyAssetsJson, borrowAssetsJson) = FOLD<12>(arr12, ([], []), walletAssetsFold)

            if (marketIndex == next) then
                (
                    accum._1 + totalWalletSupplyInUsd,
                    accum._2 + totalWalletBorrowInUsd,
                    accum._3 + totalWalletBadDebtInUsd,
                    accum._4 + totalWalletDailyIncomeInUsd,
                    accum._5 + totalWalletDailyLoanInterestInUsd,
                    totalWalletSupplyInUsd,
                    totalWalletBorrowInUsd,
                    totalWalletBadDebtInUsd,
                    totalWalletDailyIncomeInUsd,
                    totalWalletDailyLoanInterestInUsd,
                    accountHealth,
                    netApy,
                    accum._13 :+ marketsJson,
                    supplyAssetsJson,
                    borrowAssetsJson
                ) else
                (
                    accum._1 + totalWalletSupplyInUsd,
                    accum._2 + totalWalletBorrowInUsd,
                    accum._3 + totalWalletBadDebtInUsd,
                    accum._4 + totalWalletDailyIncomeInUsd,
                    accum._5 + totalWalletDailyLoanInterestInUsd,
                    accum._6,
                    accum._7,
                    accum._8,
                    accum._9,
                    accum._10,
                    accum._11,
                    accum._12,
                    accum._13 :+ marketsJson,
                    accum._14,
                    accum._15
                )
    }

    let (
    totalWalletSupplyInUsd,
    totalWalletBorrowInUsd,
    totalWalletBadDebtInUsd,
    totalWalletDailyIncomeInUsd,
    totalWalletDailyLoanInterestInUsd,
    walletSupplyInUsd,
    walletBorrowInUsd,
    walletBadDebtInUsd,
    walletDailyIncomeInUsd,
    walletDailyLoanInterestInUsd,
    walletAccountHealth,
    walletNetApy,
    marketsJson,
    supplyAssetsJson,
    borrowAssetsJson
    ) = FOLD<12>(arr12, (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, [], [], []), marketsFold)

    let json =
    "{" +
    "\"marketIndex\":" + marketIndex.toString() +
    ",\"name\":\"" + marketName + "\"" +
    ",\"totalSupplyInUsd\":" + assetToJson(usdtIdStr, totalWalletSupplyInUsd) +
    ",\"totalBorrowInUsd\":" + assetToJson(usdtIdStr, totalWalletBorrowInUsd) +
    ",\"totalBadDebtInUsd\":" + assetToJson(usdtIdStr, totalWalletBadDebtInUsd) +
    ",\"totalDailyIncomeInUsd\":" + assetToJson(usdtIdStr, totalWalletDailyIncomeInUsd) +
    ",\"totalDailyLoanInterestInUsd\":" + assetToJson(usdtIdStr, totalWalletDailyLoanInterestInUsd) +
    ",\"supplyInUsd\":" + assetToJson(usdtIdStr, walletSupplyInUsd) +
    ",\"borrowInUsd\":" + assetToJson(usdtIdStr, walletBorrowInUsd) +
    ",\"badDebtInUsd\":" + assetToJson(usdtIdStr, walletBadDebtInUsd) +
    ",\"dailyIncomeInUsd\":" + assetToJson(usdtIdStr, walletDailyIncomeInUsd) +
    ",\"dailyLoanInterestInUsd\":" + assetToJson(usdtIdStr, walletDailyLoanInterestInUsd) +
    ",\"accountHealth\":" + amountToDecimal(walletAccountHealth, 8) +
    ",\"netApy\":" + amountToDecimal(walletNetApy, 8) +
    ",\"supplyAssets\":[" + makeString_11C(supplyAssetsJson, ",") + "]" +
    ",\"borrowAssets\":[" + makeString_11C(borrowAssetsJson, ",") + "]" +
    ",\"markets\":[" + makeString_11C(marketsJson, ",") + "]" +
    "}"

    if (debug) then throw(json) else json
}

func getWalletOperationsJson(marketIndex: Int, assetIdStr: String, wallet: String, debug: Boolean) = {
    let marketStr = getStringValue("market_" + marketIndex.toString())
    let marketAddress = addressFromStringValue(marketStr)
    let marketName = getStringValue("market_name_" + marketStr)
    let active = marketAddress.getBoolean("setup_active").valueOrElse(true)
    let setupTokens = getSetupTokens(marketAddress)
    let setupCf = marketAddress.getStringValue("setup_ltvs").split_4C(",")
    let setupLt = marketAddress.getStringValue("setup_lts").split_4C(",")
    let setupPenalty = marketAddress.getStringValue("setup_penalties").split_4C(",")
    let assetIndex = getAssetIndex(setupTokens, assetIdStr)
    let cf = setupCf[assetIndex].parseIntValue()
    let lt = setupLt[assetIndex].parseIntValue()
    let penalty = setupPenalty[assetIndex].parseIntValue()
    let assetsCount = setupTokens.size()
    let lastRateHeight = getLastRateHeight(marketAddress)
    let price = getTokenPrice(marketAddress, assetIdStr)
    let assetScale = getAssetScale(assetIdStr)
    let outdatedTotalSupply = getOutdatedTotalSupply(marketAddress, assetIdStr)
    let outdatedTotalBorrow = getOutdatedTotalBorrow(marketAddress, assetIdStr)
    let outdatedSRate = getOutdatedSRate(marketAddress, assetIdStr)
    let outdatedBRate = getOutdatedBRate(marketAddress, assetIdStr)
    let outdatedUr = getOutdatedUr(outdatedTotalSupply, outdatedTotalBorrow, outdatedSRate, outdatedBRate)
    let rate = getRate(outdatedUr, assetIdStr, marketStr)
    let interest = getInterest(rate)
    let sRate = getActualSRate(lastRateHeight, interest, outdatedUr, outdatedSRate)
    let bRate = getActualBRate(lastRateHeight, interest, outdatedBRate)
    let supply = getActualAmount(outdatedTotalSupply, sRate)
    let borrow = getActualAmount(outdatedTotalBorrow, bRate)
    let supplyInUsd = getInUsd(supply, assetScale, price)
    let borrowInUsd = getInUsd(borrow, assetScale, price)
    let reserves = supply - borrow
    let reservesInUsd = getInUsd(reserves, assetScale, price)
    let ur = getActualUr(supply, borrow)
    let supplyApy = getSupplyApy(rate, ur)
    let borrowApy = getBorrowApy(rate)
    let maxSupply = getMaxSupply(marketAddress, assetIdStr)

    let walletSupply = getWalletSupply(marketAddress, assetIdStr, wallet, sRate)
    let walletSupplyInUsd = getInUsd(walletSupply, assetScale, price)
    let walletDailyIncome = getDailyPercents(supplyApy, walletSupply)
    let walletDailyIncomeInUsd = getInUsd(walletDailyIncome, assetScale, price)
    let walletBorrow = getWalletBorrow(marketAddress, assetIdStr, wallet, bRate)
    let walletBorrowInUsd = getInUsd(walletBorrow, assetScale, price)
    let walletDailyLoanPercents = getDailyPercents(borrowApy, walletBorrow)
    let walletDailyLoanPercentsInUsd = getInUsd(walletDailyLoanPercents, assetScale, price)

    func assetsFold(accum: (Int, Int, Int, Int, Int), next: Int) = {
        if (next >= assetsCount) then accum else

            let currentAssetIdStr = setupTokens[next]
            let currentCf = setupCf[next].parseIntValue()
            let currentLt = setupLt[next].parseIntValue()
            let currentPrice = getTokenPrice(marketAddress, currentAssetIdStr)
            let currentAssetScale = getAssetScale(currentAssetIdStr)
            let currentOutdatedTotalSupply = getOutdatedTotalSupply(marketAddress, currentAssetIdStr)
            let currentOutdatedTotalBorrow = getOutdatedTotalBorrow(marketAddress, currentAssetIdStr)
            let currentOutdatedSRate = getOutdatedSRate(marketAddress, currentAssetIdStr)
            let currentOutdatedBRate = getOutdatedBRate(marketAddress, currentAssetIdStr)
            let currentOutdatedUr = getOutdatedUr(currentOutdatedTotalSupply, currentOutdatedTotalBorrow, currentOutdatedSRate, currentOutdatedBRate)
            let currentRate = getRate(currentOutdatedUr, currentAssetIdStr, marketStr)
            let currentInterest = getInterest(currentRate)
            let currentSRate = getActualSRate(lastRateHeight, currentInterest, currentOutdatedUr, currentOutdatedSRate)
            let currentBRate = getActualBRate(lastRateHeight, currentInterest, currentOutdatedBRate)
            let currentSupply = getActualAmount(currentOutdatedTotalSupply, sRate)
            let currentBorrow = getActualAmount(currentOutdatedTotalBorrow, bRate)
            let currentUr = getActualUr(currentSupply, currentBorrow)
            let currentSupplyApy = getSupplyApy(currentRate, currentUr)
            let currentBorrowApy = getBorrowApy(currentRate)

            let currentWalletSupply = getWalletSupply(marketAddress, currentAssetIdStr, wallet, currentSRate)
            let currentWalletSupplyInUsd = getInUsd(currentWalletSupply, currentAssetScale, currentPrice)
            let currentWalletBorrow = getWalletBorrow(marketAddress, currentAssetIdStr, wallet, currentBRate)
            let currentWalletBorrowInUsd = getInUsd(currentWalletBorrow, currentAssetScale, currentPrice)
            let currentWalletBorrowLimitInUsd = fraction(currentWalletSupplyInUsd, currentCf, Scale8)
            let currentWalletBorrowUsageInUsd = fraction(currentWalletBorrowInUsd, Scale8, currentLt)
            let walletMarginInUsd = fraction(currentWalletSupplyInUsd, currentSupplyApy, Scale8) - fraction(currentWalletBorrowInUsd, currentBorrowApy, Scale8)

            (
                accum._1 + currentWalletSupplyInUsd,
                accum._2 + currentWalletBorrowInUsd,
                accum._3 + currentWalletBorrowLimitInUsd,
                accum._4 + currentWalletBorrowUsageInUsd,
                accum._5 + walletMarginInUsd
            )
    }

    let (totalWalletSupplyInUsd, totalWalletBorrowInUsd, totalWalletBorrowLimitInUsd, totalWalletBorrowUsageInUsd, totalWalletMarginInUsd) = FOLD<12>(arr12, (0, 0, 0, 0, 0), assetsFold)
    let accountHealth = getAccountHealth(totalWalletBorrowLimitInUsd, totalWalletBorrowUsageInUsd)
    let netApy = getNetApy(totalWalletSupplyInUsd, totalWalletBorrowInUsd, totalWalletMarginInUsd)

    let json =
    "{" +
    "\"marketIndex\":" + marketIndex.toString() +
    ",\"marketName\":\"" + marketName + "\"" +
    ",\"address\":\"" + marketStr + "\"" +
    ",\"assetPrice\":" + assetToJson(usdtIdStr, price) +
    ",\"supply\":" + assetToJson(assetIdStr, supply) +
    ",\"supplyInUsd\":" + assetToJson(usdtIdStr, supplyInUsd) +
    ",\"supplyApy\":" + amountToDecimal(supplyApy, 8) +
    ",\"borrow\":" + assetToJson(assetIdStr, borrow) +
    ",\"borrowInUsd\":" + assetToJson(usdtIdStr, borrowInUsd) +
    ",\"borrowApy\":" + amountToDecimal(borrowApy, 8) +
    ",\"reserves\":" + assetToJson(assetIdStr, reserves) +
    ",\"reservesInUsd\":" + assetToJson(usdtIdStr, reservesInUsd) +
    ",\"utilizationRatio\":" + amountToDecimal(ur, 8) +
    ",\"collateralFactor\":" + amountToDecimal(cf, 8) +
    ",\"liquidationThreshold\":" + amountToDecimal(lt, 8) +
    ",\"liquidationPenalty\":" + amountToDecimal(penalty, 8) +
    ",\"maxSupply\":" + assetToJson(usdtIdStr, maxSupply) +
    ",\"walletSupply\":" + assetToJson(assetIdStr, walletSupply) +
    ",\"walletSupplyInUsd\":" + assetToJson(usdtIdStr, walletSupplyInUsd) +
    ",\"walletDailyIncome\":" + assetToJson(assetIdStr, walletDailyIncome) +
    ",\"walletDailyIncomeInUsd\":" + assetToJson(usdtIdStr, walletDailyIncomeInUsd) +
    ",\"walletBorrow\":" + assetToJson(assetIdStr, walletBorrow) +
    ",\"walletBorrowInUsd\":" + assetToJson(usdtIdStr, walletBorrowInUsd) +
    ",\"walletDailyLoanInterest\":" + assetToJson(assetIdStr, walletDailyLoanPercents) +
    ",\"walletDailyLoanInterestInUsd\":" + assetToJson(usdtIdStr, walletDailyLoanPercentsInUsd) +
    ",\"accountHealth\":" + amountToDecimal(accountHealth, 8) +
    ",\"netApy\":" + amountToDecimal(netApy, 8) +
    "}"

    if (debug) then throw(json) else json
}

func getMarketParametersJson(marketIndex: Int, debug: Boolean) = {
    let marketStr = getStringValue("market_" + marketIndex.toString())
    let marketAddress = addressFromStringValue(marketStr)
    let marketName = getStringValue("market_name_" + marketStr)
    let setupTokens = getSetupTokens(marketAddress)
    let setupCf = marketAddress.getStringValue("setup_ltvs").split_4C(",")
    let setupLt = marketAddress.getStringValue("setup_lts").split_4C(",")
    let setupPenalty = marketAddress.getStringValue("setup_penalties").split_4C(",")
    let assetsCount = setupTokens.size()

    func assetsFold(accum: List[String], next: Int) = {
        if (next >= assetsCount) then accum else
            let assetIdStr = setupTokens[next]
            let maxSupply = getMaxSupply(marketAddress, assetIdStr)
            let cf = setupCf[next].parseIntValue()
            let lt = setupLt[next].parseIntValue()
            let penalty = setupPenalty[next].parseIntValue()

            let json =
            "{" +
            "\"asset\":" + assetToJson(assetIdStr, 0) +
            ",\"maxSupply\":" + assetToJson(usdtIdStr, maxSupply) +
            ",\"collateralFactor\":" + amountToDecimal(cf, 8) +
            ",\"liquidationThreshold\":" + amountToDecimal(lt, 8) +
            ",\"liquidationPenalty\":" + amountToDecimal(penalty, 8) +
            "}"

            accum :+ json
    }

    let assetsJson = FOLD<12>(arr12, [], assetsFold)

    let json =
    "{" +
    "\"name\":\"" + marketName + "\"" +
    ",\"assets\":[" + makeString_11C(assetsJson, ",") + "]" +
    "}"

    if (debug) then throw(json) else json
}